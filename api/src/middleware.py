from starlette.middleware.cors import CORSMiddleware as starletteCORSMW
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response
from fastapi import Request
import os

import logging
from typing import Callable
import time
import json

from services.uid_generation.UIDGenerator import UIDGenerator

class CORSMiddleware(starletteCORSMW):
    """
    Middleware for handling Cross-Origin Resource Sharing (CORS).

    This middleware extends the Starlette CORS middleware to restrict and allow cross-origin requests
    based on a predefined list of allowed origins, HTTP methods, headers, and exposed headers.
    The allowed origins are dynamically constructed using environment variables for HOST_IP and UI_HOST_PORT.

    Attributes:
        HOST_IP (str): The host IP address retrieved from the "HOST_IP" environment variable.
        UI_HOST_PORT (str): The UI host port retrieved from the "UI_HOST_PORT" environment variable.
        allowed_origins (list[str]): A list of origins allowed to access the resources.
    """

    HOST_IP = os.getenv("HOST_IP")
    UI_HOST_PORT = os.getenv("UI_HOST_PORT")

    allowed_origins = [
        f"http://{HOST_IP}:{UI_HOST_PORT}",
        f"http://localhost:{UI_HOST_PORT}",
    ]

    def __init__(self, app):
        """
        Initialize the CORSMiddleware with CORS settings.

        Configures the CORS parameters including allowed origins, HTTP methods, allowed headers,
        and headers to expose. The allowed origins include the URL built from HOST_IP and UI_HOST_PORT
        as well as a localhost URL.

        Args:
            app: The ASGI application instance to wrap with the middleware.
        """
        allow_origins = CORSMiddleware.allowed_origins
        allow_methods = ["GET", "PUT", "POST", "DELETE", "OPTIONS"]
        allow_headers = [
            "Authorization",
            "Accept",
            "Accept-Language",
            "Content-Language",
            "Content-Type",
            "X-Requested-With",
            "X-PINGOTHER",
            "request-uuid",
        ]
        expose_headers = ["request-uuid", "Content-Type"]

        super().__init__(
            app,
            allow_origins=allow_origins,
            allow_credentials=True,
            allow_methods=allow_methods,
            allow_headers=allow_headers,
            expose_headers=expose_headers,
        )


class RequestUIDMiddleware(BaseHTTPMiddleware):
    """
    Middleware for adding a unique identifier (NUID) to each incoming
    request.

    This middleware generates a unique identifier for every request using the
    UIDGenerator and attaches it to the request's state. This is useful for
    tracking, logging, or debugging purposes throughout the lifecycle of the
    request.

    Each Request object is assigned a `nuid` attribute to its `state`, accessed
    through `request.state.nuid`.
    """

    async def dispatch(self, request: Request, call_next):
        """
        Process an incoming request, attach a unique identifier, and pass the request along the middleware chain.

        Generates a NUID, assigns it to the request's state as 'nuid', and then calls the next middleware
        or endpoint handler. This unique identifier facilitates request tracing and debugging.

        Args:
            request (Request): The incoming HTTP request.
            call_next (Callable): The next middleware or endpoint handler in the processing chain.

        Returns:
            Response: The response generated by the next middleware or endpoint.
        """
        nuid = UIDGenerator.generate_request_uid()
        request.state.nuid = nuid
        response = await call_next(request)
        return response


class LogRequestMiddleware(BaseHTTPMiddleware):
    """
    ASGI middleware for logging incoming HTTP requests and outgoing responses.

    This middleware logs:
    - Request method, URL path, and client host at the start of the request.
    - Response body and duration after processing the request.
    - Errors or warnings based on the response's status code and body content.

    It captures the full response body by consuming the response's body iterator,
    logs it safely (handling binary data), and re-creates the response to ensure
    it can still be sent to the client.

    Log levels:
    - DEBUG: Initial request information.
    - INFO: Successful responses with a valid body.
    - ERROR: Responses with status_code >= 500.

    Attributes:
        dispatch (Callable): Intercepts each request/response cycle.
    """

    async def dispatch(self, request: Request, call_next: Callable):
        request_nuid = request.state.nuid
        logger = logging.getLogger(f"middleware.LogRequestMiddleware | {request_nuid}")

        start_time = time.time()
        client_host = request.client.host if request.client else "unknown"

        logger.debug(f'{request.method} "{request.url.path}" FROM "{client_host}"')

        # Continue processing the request
        response = await call_next(request)

        # Capture response body from streaming iterator
        body = b""
        async for chunk in response.body_iterator:
            body += chunk

        # Decode body for logging (handle potential binary data safely)
        try:
            body_str = body.decode("utf-8")
        except UnicodeDecodeError:
            body_str = "<Binary Content>"

        duration = time.time() - start_time

        try:
            body_obj = json.loads(body_str)

            if isinstance(body_obj, dict) and "status_code" in body_obj:
                if body_obj["status_code"] >= 500:
                    logger.error(
                        f'{request.method} "{request.url.path}" FROM "{client_host}" - RESPONSE '
                        f"Duration={duration:.4f}s Body={body_str}"
                    )
                else:
                    logger.info(
                        f'{request.method} "{request.url.path}" FROM "{client_host}" - RESPONSE '
                        f"Duration={duration:.4f}s Body={body_str}"
                    )
            else:
                # Log as info if body is not a dict with status_code
                logger.info(
                    f'{request.method} "{request.url.path}" FROM "{client_host}" - RESPONSE '
                    f"Duration={duration:.4f}s Body={body_str}"
                )

        except KeyError:
            if response.status_code >= 500:
                logger.error(
                    f'{request.method} "{request.url.path}" FROM "{client_host}" - RESPONSE '
                    f"Duration={duration:.4f}s Status Code={response.status_code} Body={body_str}"
                )
            else:
                logger.info(
                    f'{request.method} "{request.url.path}" FROM "{client_host}" - RESPONSE '
                    f"Duration={duration:.4f}s Body={body_str}"
                )

        except Exception as e:
            logger.debug(f"Error converting response body to dictionary: {e}")
            logger.info(
                f'{request.method} "{request.url.path}" FROM "{client_host}" - RESPONSE '
                f"Duration={duration:.4f}s Body={body_str}"
            )

        # Create new response with corrected Content-Length
        new_response = Response(
            content=body,
            status_code=response.status_code,
            headers={**response.headers, "Content-Length": str(len(body))},
            media_type=response.media_type,
            background=response.background,
        )

        return new_response
